service: burst-compute


plugins:
  - serverless-bundle
  - serverless-step-functions


custom:
  version: ${file(./package.json):version}
  nodeJSRuntime: nodejs18.x
  tracing: false
  debug: true
  tasksTable: ${self:service}-${self:provider.stage}-tasks
  stateMachine: ${self:service}-${self:provider.stage}-lifecycle
  defaultJobTimeoutSecs: 60


provider:
  name: aws
  region: ${opt:region, "us-east-1"}
  stage: ${opt:stage, "dev"}
  tags:
    PROJECT: BurstCompute
    VERSION: ${self:custom.version}
    DEVELOPER: ${env:USER}
  stackTags:
    PROJECT: BurstCompute
    VERSION: ${self:custom.version}
    DEVELOPER: ${env:USER}
    STAGE: ${self:provider.stage}
  tracing:
    lambda: ${self:custom.tracing}
  environment:
    AWS_NODEJS_CONNECTION_REUSE_ENABLED: 1
  iam:
    role:
      statements:
      - Effect: Allow
        Action:
          - dynamodb:Query
          - dynamodb:PutItem
        Resource: "arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tasksTable}"
      - Effect: Allow
        Action:
          - states:StartExecution
        Resource: "arn:aws:states:${self:provider.region}:*:stateMachine:${self:custom.stateMachine}"
      - Effect: Allow
        Action:
          - lambda:InvokeFunction
        Resource: "*"


package:
  individually: true
  patterns:
    - src/main/nodejs/**


functions:

  dispatch:
    runtime: ${self:custom.nodeJSRuntime}
    handler: src/main/nodejs/dispatch.dispatchHandler
    memorySize: 256
    # 5 minute timeout
    timeout: 300
    environment:
      DEBUG: ${self:custom.debug}
      JOB_TIMEOUT_SECS: ${self:custom.defaultJobTimeoutSecs}
      DISPATCH_FUNCTION_NAME: ${self:service}-${self:provider.stage}-dispatch
      MONITOR_FUNCTION_NAME: ${self:service}-${self:provider.stage}-monitor
      STATE_MACHINE_ARN: ${self:resources.Outputs.JobLifecycleStateMachine.Value}
      TASKS_TABLE_NAME: ${self:custom.tasksTable}

  monitor:
    runtime: ${self:custom.nodeJSRuntime}
    handler: src/main/nodejs/monitor.monitorHandler
    memorySize: 128
    timeout: ${self:custom.defaultJobTimeoutSecs}
    environment:
      DEBUG: ${self:custom.debug}
      JOB_TIMEOUT_SECS: ${self:custom.defaultJobTimeoutSecs}
      TASKS_TABLE_NAME: ${self:custom.tasksTable}


stepFunctions:
  validate: true # enable pre-deployment definition validation
  stateMachines:

    jobLifecycleStateMachine:
      id: JobLifecycleStateMachine
      name: ${self:custom.stateMachine}
      definition:
        Comment: "Monitors a burst compute job and calls the combiner when all tasks are done"
        StartAt: MapJobs
        States:
          MapJobs:
            Type: Map
            InputPath: "$"
            ItemsPath: "$.batches"
            ItemSelector:
              jobId.$: "$$.Execution.Input.jobId"
              startTime.$: "$$.Execution.Input.startTime"
              numBatches.$: "$$.Execution.Input.numBatches"
              searchTimeoutSecs.$: "$$.Execution.Input.searchTimeoutSecs"
              jobParameters.$: "$$.Execution.Input.jobParameters"
              workerFunctionName.$: "$$.Execution.Input.workerFunctionName"
              tasksTableName.$: "$$.Execution.Input.tasksTableName"
              batchId.$: "$$.Map.Item.Value.batchId"
              startIndex.$: "$$.Map.Item.Value.startIndex"
              endIndex.$: "$$.Map.Item.Value.endIndex"
            ItemProcessor:
              ProcessorConfig:
                Mode: DISTRIBUTED
                ExecutionType: STANDARD
              StartAt: ExecuteBatch
              States:
                ExecuteBatch:
                  Type: Task
                  Resource: arn:aws:states:::lambda:invoke
                  Parameters:
                    FunctionName.$: "$$.Execution.Input.workerFunctionName"
                    InvocationType: "RequestResponse"
                    Payload.$: "$"
                  OutputPath: "$.Payload"
                  Next: PersistResults
                PersistResults:
                  Type: Task
                  Resource: arn:aws:states:::dynamodb:putItem
                  Parameters:
                    TableName.$: "$$.Execution.Input.tasksTableName"
                    Item:
                      jobId.$: "$.jobId"
                      batchId: 
                        N.$: "$.batchId"
                      resultsMimeType.$: "$.resultsMimeType"
                      results.$: "$.results"
                      nresults:
                        N.$: "$.nresults"
                      ttl:
                        N.$: "$.ttl"
                  ResultPath: null
                  End: true
            ResultPath: null
            Catch:
              - ErrorEquals:
                - States.ALL
                Next: CombineError
                ResultPath: "$.fatalErrors[0]"
            Next: AreWeDone
          AreWeDone:
            Type: Choice
            Choices:
              - Variable: "$.lastBatchId"
                NumericLessThanPath: "$.numBatches"
                Next: DispatchNextJobs
            Default: Combine
          DispatchNextJobs:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              FunctionName.$: "$$.Execution.Input.dispatchFunctionName"
              InvocationType: "RequestResponse"
              Payload:
                jobId.$: "$.jobId"
                datasetStartIndex.$: "$$.Execution.Input.datasetStartIndex"
                datasetEndIndex.$: "$$.Execution.Input.datasetEndIndex"
                batchSize.$: "$.batchSize"
                startTime.$: "$.startTime"
                firstBatchId.$: "$.firstBatchId"
                lastBatchId.$: "$.lastBatchId"
                numBatches.$: "$.numBatches"
                searchTimeoutSecs.$: "$.searchTimeoutSecs"
                jobParameters.$: "$.jobParameters"
                dispatchFunctionName.$: "$.dispatchFunctionName"
                workerFunctionName.$: "$.workerFunctionName"
                combinerFunctionName.$: "$.combinerFunctionName"
                monitorFunctionName.$: "$.monitorFunctionName"
                tasksTableName.$: "$.tasksTableName"
            OutputPath: "$.Payload"
            Next: MapJobs
          Combine:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              FunctionName.$: "$$.Execution.Input.combinerFunctionName"
              Payload.$: "$"
            OutputPath: "$"
            Catch:
              - ErrorEquals:
                - States.ALL
                Next: CombineError
                ResultPath: "$.fatalErrors[0]"
            Next: EndState
          CombineError:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              FunctionName.$: "$$.Execution.Input.combinerFunctionName"
              Payload.$: "$"
            Next: EndState
          EndState:
            Type: Pass
            End: true


resources:

  Resources:
    TasksTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tasksTable}
        KeySchema:
          - AttributeName: jobId
            KeyType: HASH
          - AttributeName: batchId
            KeyType: RANGE
        AttributeDefinitions:
          - AttributeName: jobId
            AttributeType: S
          - AttributeName: batchId
            AttributeType: N
        BillingMode: PAY_PER_REQUEST
        TimeToLiveSpecification:
          AttributeName: ttl
          Enabled: true

  Outputs:
    TasksTable:
      Description: Name of the tasks table
      Value:
        "Ref": TasksTable
      Export:
        Name: BurstComputeTasksTable-${self:provider.stage}
    JobLifecycleStateMachine:
      Description: The ARN of the state machine
      Value:
        Ref: JobLifecycleStateMachine
    DispatchLambdaFunction:
      Description: Name of the dispatch function
      Value:
        Ref: DispatchLambdaFunction
      Export:
        Name: BurstComputeDispatchLambdaFunction-${self:provider.stage}
    MonitorLambdaFunction:
      Description: Name of the monitor function
      Value:
        Ref: MonitorLambdaFunction
      Export:
        Name: BurstComputeMonitorLambdaFunction-${self:provider.stage}
