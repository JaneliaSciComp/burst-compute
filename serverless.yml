service: burst-compute

plugins:
  - serverless-step-functions
  - serverless-plugin-package-json

custom:
  version: ${pkgjson:version}
  tracing: false
  debug: "true"
  tasksTable: ${self:service}-${self:provider.stage}-tasks
  jobTimeoutInSeconds: "300"

provider:
  name: aws
  region: ${opt:region, "us-east-1"}
  stage: ${opt:stage, "dev"}
  tags:
    PROJECT: BurstCompute
    VERSION: ${self:custom.version}
    DEVELOPER: ${env:USER}
  stackTags:
    PROJECT: BurstCompute
    VERSION: ${self:custom.version}
    DEVELOPER: ${env:USER}
    STAGE: ${self:provider.stage}
  tracing:
    lambda: ${self:custom.tracing}
  environment:
    AWS_NODEJS_CONNECTION_REUSE_ENABLED: "1"
  iamRoleStatements:
    - Effect: "Allow"
      Action:
        - dynamodb:DescribeStream
        - dynamodb:DescribeTable
        - dynamodb:GetRecords
        - dynamodb:ListStreams
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:UpdateTable
        - dynamodb:Query
      Resource: "arn:aws:dynamodb:${self:provider.region}:*:table/${self:custom.tasksTable}"
    - Effect: Allow
      Action:
        - lambda:InvokeFunction
        - lambda:InvokeAsync
      Resource: "*"
    - Effect: Allow
      Action:
        - states:StartExecution
      Resource: "*"

package:
  individually: true
  exclude:
    - src/test/**
  include:
    - src/main/nodejs/**

functions:

  dispatch:
    runtime: nodejs12.x
    handler: src/main/nodejs/dispatch.dispatchHandler
    memorySize: 256
    # 5 minute timeout
    timeout: 300
    environment:
      DISPATCH_FUNCTION_NAME: ${self:service}-${self:provider.stage}-dispatch
      MONITOR_FUNCTION_NAME: ${self:resources.Outputs.MonitorLambdaFunction.Value}
      STATE_MACHINE_NAME: ${self:resources.Outputs.JobLifecycleStateMachine.Value}
      DEBUG: ${self:custom.debug}

  monitor:
    runtime: nodejs12.x
    handler: src/main/nodejs/monitor.monitorHandler
    memorySize: 128
    # 10 second timeout
    timeout: 10
    environment:
      JOB_TIMEOUT_SECS: ${self:custom.jobTimeoutInSeconds}
      JOB_TABLE_NAME: ${self:custom.tasksTable}
      DEBUG: ${self:custom.debug}

stepFunctions:
  validate: true # enable pre-deployment definition validation
  stateMachines:

    jobLifecycleStateMachine:
      id: JobLifecycleStateMachine
      name: ${self:service}-${self:provider.stage}-lifecycle
      definition:
        Comment: "Monitors a burst compute job and calls the reducer when all tasks are done"
        StartAt: Monitor
        States:
          Monitor:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              FunctionName.$: "$$.Execution.Input.monitorFunctionArn"
              Payload.$: "$"
            OutputPath: "$.Payload"
            Retry:
              - ErrorEquals: 
                - Lambda.TooManyRequestsException
                IntervalSeconds: 1
                MaxAttempts: 100
            Next: IsTimedOut
          IsTimedOut:
            Type: Choice
            Choices:
              - Variable: "$.timedOut"
                BooleanEquals: true
                Next: Reduce
            Default: AreWeDoneYet
          AreWeDoneYet:
            Type: Choice
            Choices:
              - Variable: "$.completed"
                BooleanEquals: true
                Next: Reduce
            Default: Wait
          Wait:
            Type: Wait
            Seconds: 1
            Next: Monitor
          Reduce:
            Type: Task
            Resource: arn:aws:states:::lambda:invoke
            Parameters:
              FunctionName.$: "$$.Execution.Input.reduceFunctionArn"
              Payload.$: "$"
            OutputPath: "$.Payload"
            Next: EndState
          EndState:
            Type: Pass
            End: true
 
resources:

  Outputs:
    MonitorLambdaFunction:
      Description: The ARN of the monitor function
      Value:
        Ref: MonitorLambdaFunction
    JobLifecycleStateMachine:
      Description: The ARN of the state machine
      Value:
        Ref: JobLifecycleStateMachine

  Resources:
    TasksTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:custom.tasksTable}
        KeySchema:
          - AttributeName: jobId
            KeyType: HASH
          - AttributeName: batchId
            KeyType: RANGE
        AttributeDefinitions:
          - AttributeName: jobId
            AttributeType: S
          - AttributeName: batchId
            AttributeType: N
        BillingMode: PAY_PER_REQUEST
